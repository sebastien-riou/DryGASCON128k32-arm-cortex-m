#ifndef __DRYGASCON128K32_VALIDATION_H__
#define __DRYGASCON128K32_VALIDATION_H__

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <string.h>

/**
 * \brief Encrypts and authenticates a packet with an AEAD scheme.
 *
 * \param c Buffer to receive the output.
 * \param clen On exit, set to the length of the output which includes
 * the ciphertext and the authentication tag.
 * \param m Buffer that contains the plaintext message to encrypt.
 * \param mlen Length of the plaintext message in bytes.
 * \param ad Buffer that contains associated data to authenticate
 * along with the packet but which does not need to be encrypted.
 * \param adlen Length of the associated data in bytes.
 * \param nsec Secret nonce - normally not used by AEAD schemes.
 * \param npub Points to the public nonce for the packet.
 * \param k Points to the key to use to encrypt the packet.
 *
 * \return 0 on success, or a negative value if there was an error in
 * the parameters.
 */
typedef int (*aead_cipher_encrypt_t)
    (unsigned char *c, unsigned long long *clen,
     const unsigned char *m, unsigned long long mlen,
     const unsigned char *ad, unsigned long long adlen,
     const unsigned char *nsec,
     const unsigned char *npub,
     const unsigned char *k);

/**
 * \brief Decrypts and authenticates a packet with an AEAD scheme.
 *
 * \param m Buffer to receive the plaintext message on output.
 * \param mlen Receives the length of the plaintext message on output.
 * \param nsec Secret nonce - normally not used by AEAD schemes.
 * \param c Buffer that contains the ciphertext and authentication
 * tag to decrypt.
 * \param clen Length of the input data in bytes, which includes the
 * ciphertext and the authentication tag.
 * \param ad Buffer that contains associated data to authenticate
 * along with the packet but which does not need to be encrypted.
 * \param adlen Length of the associated data in bytes.
 * \param npub Points to the public nonce for the packet.
 * \param k Points to the key to use to decrypt the packet.
 *
 * \return 0 on success, -1 if the authentication tag was incorrect,
 * or some other negative number if there was an error in the parameters.
 */
typedef int (*aead_cipher_decrypt_t)
    (unsigned char *m, unsigned long long *mlen,
     unsigned char *nsec,
     const unsigned char *c, unsigned long long clen,
     const unsigned char *ad, unsigned long long adlen,
     const unsigned char *npub,
     const unsigned char *k);

/**
 * \brief Hashes a block of input data.
 *
 * \param out Buffer to receive the hash output.
 * \param in Points to the input data to be hashed.
 * \param inlen Length of the input data in bytes.
 *
 * \return Returns zero on success or -1 if there was an error in the
 * parameters.
 */
typedef int (*hash_t)
    (unsigned char *out, const unsigned char *in, unsigned long long inlen);


static int drygascon128k32_validate_encrypt(aead_cipher_encrypt_t enc){
    uint8_t key[] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F};
    uint8_t nonce[] = {0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF};
    uint8_t c[256];
    unsigned long long clen; 
    {//test vector given in specification
        uint8_t expected[] = {0x36,0x30,0x01,0xDC,0xCA,0x22,0x0E,0x28,0x47,0x0E,0xA4,0x2E,0x63,0xC9,0xA2,0xAF};
        if(enc(c,&clen,0,0,0,0,0,nonce,key)) return __LINE__;
        if(memcmp(expected,c,sizeof(expected))) return __LINE__;
    }
    {
        uint8_t expected[] = {0xE1,0xCE,0x43,0xD1,0x40,0xAF,0x0D,0x29,0xBC,0xC6,0x78,0xA3,0x07,0x43,0xEE,0xED};
        uint8_t ad[] = {0x00};
        if(enc(c,&clen,0,0,ad,sizeof(ad),0,nonce,key)) return __LINE__;
        if(memcmp(expected,c,sizeof(expected))) return __LINE__;
    }
    {
        uint8_t expected[] = {0xAE,0x6B,0xB8,0x81,0xB7,0xFD,0x23,0x73,0x5F,0x34,0x11,0x3A,0x1E,0x29,0xC7,0x6D};
        uint8_t ad[] = {0x01};
        if(enc(c,&clen,0,0,ad,sizeof(ad),0,nonce,key)) return __LINE__;
        if(memcmp(expected,c,sizeof(expected))) return __LINE__;
    }
    {
        uint8_t expected[] = {0x74,0x51,0x5B,0x8E,0x6D,0xEB,0x7E,0xF1,0xCE,0x2C,0x85,0x96,0x69,0xFB,0x1F,0x2F};
        uint8_t ad[] = {0x00,0x01};
        if(enc(c,&clen,0,0,ad,sizeof(ad),0,nonce,key)) return __LINE__;
        if(memcmp(expected,c,sizeof(expected))) return __LINE__;
    }
    {
        uint8_t expected[] = {0xFE,0x01,0xCF,0x90,0x71,0xB7,0x71,0xAB,0x81,0xF8,0x95,0x18,0x93,0xC8,0xB5,0x4B};
        uint8_t ad[] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E};
        if(enc(c,&clen,0,0,ad,sizeof(ad),0,nonce,key)) return __LINE__;
        if(memcmp(expected,c,sizeof(expected))) return __LINE__;
    }
    {
        uint8_t expected[] = {0xCC,0xF6,0x7A,0xAD,0x1F,0xF3,0xCF,0x21,0x3D,0x4B,0xE4,0x8E,0x26,0x28,0x12,0x4C};
        uint8_t ad[] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F};
        if(enc(c,&clen,0,0,ad,sizeof(ad),0,nonce,key)) return __LINE__;
        if(memcmp(expected,c,sizeof(expected))) return __LINE__;
    }
    {
        uint8_t expected[] = {0xC5,0x6F,0x93,0x27,0xD6,0x44,0xF9,0x26,0xAD,0x5E,0xF5,0xDF,0x4B,0xF1,0xF7,0x1E};
        uint8_t ad[] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10};
        if(enc(c,&clen,0,0,ad,sizeof(ad),0,nonce,key)) return __LINE__;
        if(memcmp(expected,c,sizeof(expected))) return __LINE__;
    }
    {
        uint8_t expected[] = {0xA2,0x8F,0xA4,0xA2,0x5C,0xE9,0x24,0x2C,0xCB,0x54,0x36,0x75,0xA4,0x3B,0x8B,0x5B,0x63};
        uint8_t m[] = {0x00};
        if(enc(c,&clen,m,sizeof(m),0,0,0,nonce,key)) return __LINE__;
        if(memcmp(expected,c,sizeof(expected))) return __LINE__;
    }
    {
        uint8_t expected[] = {0xA3,0x17,0x9A,0x9E,0x2C,0xFA,0x1F,0x50,0xF8,0x25,0x5A,0x98,0x54,0xD4,0x15,0x4B,0x21};
        uint8_t m[] = {0x01};
        if(enc(c,&clen,m,sizeof(m),0,0,0,nonce,key)) return __LINE__;
        if(memcmp(expected,c,sizeof(expected))) return __LINE__;
    }
    {
        uint8_t expected[] = {0xA2,0x6A,0x83,0xA2,0x72,0x00,0xF3,0x68,0x38,0x4C,0xB9,0xF0,0x9F,0x43,0x4D,0x21,0xD4,0x74};
        uint8_t m[] = {0x00,0x01};
        if(enc(c,&clen,m,sizeof(m),0,0,0,nonce,key)) return __LINE__;
        if(memcmp(expected,c,sizeof(expected))) return __LINE__;
    }
    {
        uint8_t expected[] = {0xA2,0x6A,0x4B,0x46,0x05,0x5D,0x1C,0x44,0x16,0x5E,0x35,0x2B,0xA1,0x4C,0x71,0x4F,0x07,0x86,0x26,0xF0,0xE7,0xF1,0x01,0xB3,0x12,0xE4,0xD8,0x14,0x4C,0x42,0x99,0xDA,0xB5};
        uint8_t m[] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10};
        if(enc(c,&clen,m,sizeof(m),0,0,0,nonce,key)) return __LINE__;
        if(memcmp(expected,c,sizeof(expected))) return __LINE__;
    }
    {
        uint8_t expected[] = {0x8B,0xB1,0x39,0x37,0x0F,0xF6,0x6A,0x4A,0x1E,0x10,0x22,0x45,0x9C,0x3F,0xE4,0x5C,0xD3,0xC6,0x82,0x47,0xA6,0xA1,0x29,0xF3,0x50,0x22,0x27,0x9D,0x0A,0xBB,0x1B,0xFA,0xEF};
        uint8_t ad[] = {0xAA,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F};
        uint8_t m[] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10};
        if(enc(c,&clen,m,sizeof(m),ad,sizeof(ad),0,nonce,key)) return __LINE__;
        if(memcmp(expected,c,sizeof(expected))) return __LINE__;
    }
    
    return 0;
}


static int drygascon128k32_validate_decrypt(aead_cipher_decrypt_t dec){
    uint8_t key[] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F};
    uint8_t nonce[] = {0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF};
    uint8_t m[256];
    unsigned long long mlen; 
    {//test vector given in specification
        uint8_t ciphertext[] = {0x36,0x30,0x01,0xDC,0xCA,0x22,0x0E,0x28,0x47,0x0E,0xA4,0x2E,0x63,0xC9,0xA2,0xAF};
        if(dec(0,&mlen,0,ciphertext,sizeof(ciphertext),0,0,nonce,key)) return __LINE__;
        if(mlen!=0) return __LINE__;
    }
    {
        uint8_t ciphertext[] = {0xE1,0xCE,0x43,0xD1,0x40,0xAF,0x0D,0x29,0xBC,0xC6,0x78,0xA3,0x07,0x43,0xEE,0xED};
        uint8_t ad[] = {0x00};
        if(dec(0,&mlen,0,ciphertext,sizeof(ciphertext),ad,sizeof(ad),nonce,key)) return __LINE__;
        if(mlen!=0) return __LINE__;
    }
    {
        uint8_t ciphertext[] = {0xAE,0x6B,0xB8,0x81,0xB7,0xFD,0x23,0x73,0x5F,0x34,0x11,0x3A,0x1E,0x29,0xC7,0x6D};
        uint8_t ad[] = {0x01};
        if(dec(0,&mlen,0,ciphertext,sizeof(ciphertext),ad,sizeof(ad),nonce,key)) return __LINE__;
        if(mlen!=0) return __LINE__;
    }
    {
        uint8_t ciphertext[] = {0x8B,0xB1,0x39,0x37,0x0F,0xF6,0x6A,0x4A,0x1E,0x10,0x22,0x45,0x9C,0x3F,0xE4,0x5C,0xD3,0xC6,0x82,0x47,0xA6,0xA1,0x29,0xF3,0x50,0x22,0x27,0x9D,0x0A,0xBB,0x1B,0xFA,0xEF};
        uint8_t ad[] = {0xAA,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F};
        uint8_t expected[] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10};
        if(dec(m,&mlen,0,ciphertext,sizeof(ciphertext),ad,sizeof(ad),nonce,key)) return __LINE__;
        if(mlen!=sizeof(expected)) return __LINE__;
        if(memcmp(expected,m,sizeof(expected))) return __LINE__;
    }
    return 0;
}

static int drygascon128_validate_hash(hash_t hash){
    uint8_t digest[32];
    {//test vector given in specification
        uint8_t m[] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07};
        uint8_t expected[] = {0xCD,0xE2,0xDE,0xE0,0x23,0x53,0x45,0xCB,0xFA,0x51,0xEC,0x2C,0xE5,0x74,0x35,0x71,0x8E,0xC0,0x13,0x3E,0xC2,0x75,0x6E,0x03,0x5F,0xA4,0x04,0xC1,0xCE,0x51,0x1E,0x24};
        if(hash(digest,m,sizeof(m))) return __LINE__;
        if(memcmp(expected,digest,sizeof(expected))) return __LINE__;
    }
    {//test vector given in specification
        uint8_t expected[] = {0x1E,0xDC,0x77,0x38,0x6E,0x20,0xA3,0x7C,0x72,0x1D,0x6E,0x77,0xAD,0xAB,0xB9,0xC4,0x83,0x0F,0x19,0x9F,0x5E,0xD2,0x52,0x84,0xA1,0x3C,0x1D,0x84,0xB9,0xFC,0x25,0x7A};
        if(hash(digest,0,0)) return __LINE__;
        if(memcmp(expected,digest,sizeof(expected))) return __LINE__;
    }
    {//test vector given in specification
        uint8_t m[] = {0x00};
        uint8_t expected[] = {0x1B,0xEC,0x89,0x50,0x6E,0x75,0xD7,0x25,0xBF,0x93,0xBC,0xCF,0xDD,0x6E,0xC8,0x1D,0xF0,0x5C,0xA2,0x81,0xCF,0x52,0x01,0xE3,0xEE,0x08,0x65,0xA7,0x06,0x37,0x63,0xEE};
        if(hash(digest,m,sizeof(m))) return __LINE__;
        if(memcmp(expected,digest,sizeof(expected))) return __LINE__;
    }
    {//test vector given in specification
        uint8_t m[] = {0x00,0x01};
        uint8_t expected[] = {0x0F,0xE4,0xED,0x67,0xEA,0x1F,0xF7,0x05,0xE9,0x4E,0x6D,0x8A,0xF0,0x71,0x97,0x72,0x8C,0x1F,0xC2,0xD7,0xD5,0xAC,0xCE,0xCB,0x8D,0x08,0xCF,0x39,0xAE,0x4D,0x20,0x8D};
        if(hash(digest,m,sizeof(m))) return __LINE__;
        if(memcmp(expected,digest,sizeof(expected))) return __LINE__;
    }
    {//test vector given in specification
        uint8_t m[] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E};
        uint8_t expected[] = {0x96,0xC2,0xD3,0x04,0xE4,0x07,0x55,0x09,0x1B,0xA9,0xDB,0xBC,0xDC,0x8B,0x1F,0x5D,0x7A,0x59,0xD9,0x49,0xA4,0xAA,0x94,0x49,0x0B,0x57,0xA2,0x32,0xB7,0x69,0x2A,0xCE};
        if(hash(digest,m,sizeof(m))) return __LINE__;
        if(memcmp(expected,digest,sizeof(expected))) return __LINE__;
    }
    {//test vector given in specification
        uint8_t m[] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F};
        uint8_t expected[] = {0x57,0x28,0x21,0xD8,0x0D,0x94,0x3E,0x15,0x3C,0xBB,0x8C,0x45,0x56,0xC3,0xAD,0x8C,0xF2,0x0D,0x77,0xED,0xAD,0x79,0x98,0xE8,0xCD,0x46,0xF5,0x90,0xD8,0xD1,0x3E,0xEB};
        if(hash(digest,m,sizeof(m))) return __LINE__;
        if(memcmp(expected,digest,sizeof(expected))) return __LINE__;
    }
    {//test vector given in specification
        uint8_t m[] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10};
        uint8_t expected[] = {0x20,0xCD,0xB7,0x89,0x74,0xD6,0x92,0x10,0x06,0x12,0x97,0x80,0x96,0xCC,0xFE,0x82,0xE3,0x9F,0x15,0x96,0x9F,0x49,0x3F,0xAD,0x8F,0xA8,0x70,0xF9,0x3B,0x72,0x52,0xEA};
        if(hash(digest,m,sizeof(m))) return __LINE__;
        if(memcmp(expected,digest,sizeof(expected))) return __LINE__;
    }
    {//from Python reference implementation
        uint8_t m[] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x01};
        uint8_t expected[] = {0x87,0xF7,0x5E,0x5C,0x3A,0xA9,0x0D,0x83,0xC0,0x25,0x20,0x9A,0x3E,0xC7,0x1E,0xE0,0x25,0x10,0x5E,0x51,0x7A,0xEC,0x36,0x3C,0x4F,0x5C,0x22,0xBD,0x4F,0xAE,0x26,0xBF};
        if(hash(digest,m,sizeof(m))) return __LINE__;
        if(memcmp(expected,digest,sizeof(expected))) return __LINE__;
    }
    {//from Python reference implementation
        uint8_t m[] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x01};
        uint8_t expected[] = {0x84,0x82,0x61,0x9A,0x2D,0x44,0xC5,0xBF,0x4F,0xE2,0x8A,0x2D,0xB9,0x72,0x28,0x62,0x33,0x83,0x3B,0xDA,0xF7,0xC4,0xD6,0x89,0x7E,0x98,0x9B,0x1A,0xA4,0xE3,0x0B,0x61};
        if(hash(digest,m,sizeof(m))) return __LINE__;
        if(memcmp(expected,digest,sizeof(expected))) return __LINE__;
    }
    {//from Python reference implementation
        uint8_t m[] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x01};
        uint8_t expected[] = {0x43,0x7A,0xCB,0x5C,0xEA,0xD1,0x22,0x6F,0x88,0xE7,0x4D,0x25,0x31,0x74,0x8E,0xF4,0x00,0x5C,0x51,0x14,0x78,0xAC,0x50,0x55,0x90,0xF5,0xDE,0xB7,0x3F,0x29,0xB8,0x31};
        if(hash(digest,m,sizeof(m))) return __LINE__;
        if(memcmp(expected,digest,sizeof(expected))) return __LINE__;
    }
    return 0;
}

static int drygascon128k32_validate_all(
    aead_cipher_encrypt_t enc,
    aead_cipher_decrypt_t dec,
    hash_t hash
){
    int out;
    out=drygascon128k32_validate_encrypt(enc);
    if(out) return out;
    out=drygascon128k32_validate_decrypt(dec);
    if(out) return out;
    out=drygascon128_validate_hash(hash);
    return out;
}


#ifdef __cplusplus
}
#endif

#endif
